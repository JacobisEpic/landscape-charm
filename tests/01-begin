#!/usr/bin/python3
"""
This test creates a real landscape deployment, and runs some checks against it.
"""

import amulet
import json
import os.path
import sys
import unittest
from subprocess import check_output, STDOUT
from time import sleep
import yaml

#TODO:
# - amulet bug: juju-deployer include directives don't take path into
#               consideration
# - amulet bug: couldn't get sentries to work... need to retry
# - amulet bug: juju environment is assumed from the data file.
# - amulet bug: proper juju deployer files are assembled from multiple
#               stanzas, amulet doesn't appear to support this.
# - amulet bug: it chokes if the config file doesn't contain all stanzas


class ServiceNotFound(Exception):
    """
    Exception thrown if a service cannot be found in the deployment.
    """

    def __init__(self, service_name):
        self.service_name = service_name

class LandscapeLiveTests(unittest.TestCase):
    """
    Class hosting all the tests we want to run against a Landscape deployment.
    """

    @classmethod
    def setUpClass(cls):
        """Starts the actual Landscape charm deployment. Runs once."""
        d = amulet.Deployment(sentries=False)
        with open("test-config.yaml", "r") as myfile:
            data = yaml.load(myfile.read())
        d.load(data)
        d.setup(timeout=2000)
        cls.juju_status = cls._juju_status()

    @classmethod
    def _juju_status(self):
        """Return a juju status structure."""
        cmd = ["juju", "status", "--format=json"]
        output = check_output(cmd).decode('utf-8').strip()
        return json.loads(output)

    def _find_address(self, service_name):
        """
        Given a service name, return the public address of its first unit.
        Doesn't handle subordinates, sorry.
        """
        services = self.juju_status["services"]
        if service_name not in services:
            raise ServiceNotFound(service_name)
        service = services[service_name]
        units = service.get("units", {})
        unit_keys = list(sorted(units.keys()))
        if unit_keys:
            public_address = units[unit_keys[0]].get("public-address", "")
            return public_address
        else:
            raise ServiceNotFound(service_name)

    def _check_url(self, url, good_content, post_data=None, header=None,
                   interval=10, attempts=30):
        """
        Polls the given URL looking for the specified good_content. Fails if
        the content cannot be found in time, otherwise returns True.

        @param url: URL to poll
        @param good_content: string we are looking for
        @param post_data: optional POST data string
        @param header: optional request header string
        @param interval: number of seconds between polls
        @param attempts: how many times we should poll
        """
        output = ""
        cmd = ["curl", url, "-k", "-L", "-s"]
        if post_data:
            cmd.extend(["-d", post_data])
        if header:
            cmd.extend(["-H", header])
        while True: 
            output = check_output(cmd).decode('utf-8').strip()
            if good_content in output:
                break
            attempts = attempts - 1
            if attempts == 0:
                break
            sys.stdout.write(".")
            sys.stdout.flush()
            sleep(interval)
        self.assertIn(good_content, output)

    def __str__(self):
        file_name = os.path.splitext(os.path.basename(__file__))[0]
        return "{} ({}.{})".format(
            self._testMethodName, file_name, self.__class__.__name__)

    def test_app(self):
        """Verify that the APP service is up.

        Specifically that it is reachable and that it presents the new
        user form.
        """
        good_content = "New user - Landscape"
        frontend = self._find_address("apache2")
        self._check_url("https://{}/".format(frontend), good_content)

    def test_msg(self):
        """Verify that the MSG service is up.

        Specifically that it is reachable and that it responds
        correctly to requests.
        """
        good_content = "ds8:messagesl;s11:server-uuid"
        post_data = "ds8:messagesl;s22:next-expected-sequencei0;s8:sequencei0;;"
        header = "X-MESSAGE-API: 3.1"
        frontend = self._find_address("apache2")
        self._check_url("https://{}/message-system".format(frontend),
                        good_content, post_data, header)

    def test_ping(self):
        """Verifies that the PING service is up.

        Specifically that it is reachable and that it responds
        correctly to a ping request without an ID.
        """
        good_content = "ds5:errors19:provide insecure_id;"
        frontend = self._find_address("apache2")
        self._check_url("http://{}/ping".format(frontend), good_content)

    def test_ssh(self):
        """Verify that the landscape/0 unit can be reached via ssh."""
        good_content = "buffers/cache"
        output = check_output(["juju", "ssh", "landscape/0", "free -m"],
                              stderr=STDOUT).decode('utf-8')
        self.assertIn(good_content, output)

    def _get_service_config(self, service_name):
        """
        Returns the configuration of the given service. Raises an error if
        the service is not there.
        
        @param service_name: string representing the service we are looking for.
        """
        services = self.juju_status["services"]
        if service_name not in services:
            raise ServiceNotFound(service_name)
        cmd = ["juju", "get", "--format=yaml", service_name]
        output = check_output(cmd).decode('utf-8').strip()
        return yaml.load(output)

    def _find_cron_unit(self):
        """
        Find which landscape unit has the cron service on it.
        """
        services = self.juju_status["services"]
        for service_name in services.keys():
            if not service_name.startswith("landscape"):
                continue
            config = self._get_service_config(service_name)
            landscape_services = config["settings"]["services"]["value"]
            if "cron" not in landscape_services:
                continue
            service = services[service_name]
            units = service.get("units", {})
            unit_keys = list(sorted(units.keys()))
            if unit_keys:
                return unit_keys[0]

    def test_cron(self):
        """
        Verifies that the cron jobs run without errors.
        """
        cron_unit = self._find_cron_unit()
        cron_jobs = {
            "maintenance": "/opt/canonical/landscape/scripts/maintenance.sh",
            "update_security_db":
                "/opt/canonical/landscape/scripts/update_security_db.sh",
            "update_alerts":
                "/opt/canonical/landscape/scripts/update_alerts.sh",
            "process_profiles":
                "/opt/canonical/landscape/scripts/process_profiles.sh",
            "process_alerts":
                "/opt/canonical/landscape/scripts/process_alerts.sh",
            "hash_id_databases":
                "/opt/canonical/landscape/scripts/hash_id_databases.sh",
            "meta_releases":
                "/opt/canonical/landscape/scripts/meta_releases.sh",
            "sync_lds_releases":
                "/opt/canonical/landscape/scripts/sync_lds_releases.sh",
            "maas_poller": "/opt/canonical/landscape/scripts/maas_poller.sh"
        }
        for cron_job,script in cron_jobs.items():
            # -q is to keep ssh quiet so that the only output we get is
            # from the script we are running
            cmd = ["juju", "ssh", cron_unit, "-q", "sudo", "-u landscape",
                   script]
            # these jobs currently don't set their exit status to non-zero
            # if they fail, they just print things to stdout/stderr
            output = check_output(cmd, stderr=STDOUT).decode("utf-8").strip()
            self.assertIs(len(output), 0)


if __name__ == "__main__":
    unittest.main(verbosity=2)
