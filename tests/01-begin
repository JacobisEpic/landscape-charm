#!/usr/bin/python3
"""
This test creates a real landscape deployment, and runs some checks against it.
"""

import amulet
import json
import os.path
import sys
import unittest
from subprocess import check_output, STDOUT, CalledProcessError
from time import sleep
import yaml

#TODO:
# - amulet bug: juju-deployer include directives don't take path into
#               consideration
# - amulet bug: couldn't get sentries to work... need to retry
# - amulet bug: juju environment is assumed from the data file.
# - amulet bug: proper juju deployer files are assembled from multiple
#               stanzas, amulet doesn't appear to support this.
# - amulet bug: it chokes if the config file doesn't contain all stanzas


def setUpModule():
    """Deploys Landscape via the charm. All the tests use this deployment."""
    d = amulet.Deployment(sentries=False)
    with open("test-config.yaml", "r") as myfile:
        data = yaml.load(myfile.read())
    d.load(data)
    d.setup(timeout=2000)


def juju_status():
    """Return a juju status structure."""
    cmd = ["juju", "status", "--format=json"]
    output = check_output(cmd).decode("utf-8").strip()
    return json.loads(output)


def get_service_config(service_name):
    """
    Returns the configuration of the given service. Raises an error if
    the service is not there.

    @param juju_status: dictionary representing the juju status output.
    @param service_name: string representing the service we are looking for.
    """
    cmd = ["juju", "get", "--format=yaml", service_name]
    output = check_output(cmd).decode("utf-8").strip()
    return yaml.load(output)


def find_address(juju_status, service_name):
    """
    Find the first unit of service_name in the given juju status dictionary.
    Doesn't handle subordinates, sorry.

    @param juju_status: dictionary representing the juju status output.
    @param service_name: String representing the name of the service.
    """
    services = juju_status["services"]
    if service_name not in services:
        raise ServiceNotFound(service_name)
    service = services[service_name]
    units = service.get("units", {})
    unit_keys = list(sorted(units.keys()))
    if unit_keys:
        public_address = units[unit_keys[0]].get("public-address", "")
        return public_address
    else:
        raise ServiceNotFound(service_name)


def find_cron_unit(juju_status):
    """
    Find the first landscape unit that has the cron service on it.

    @param juju_status: dictionary representing the juju status output.
    """
    services = juju_status["services"]
    for service_name in services.keys():
        if not service_name.startswith("landscape"):
            continue
        config = get_service_config(service_name)
        landscape_services = config["settings"]["services"]["value"]
        if "cron" not in landscape_services:
            continue
        service = services[service_name]
        units = service.get("units", {})
        unit_keys = list(sorted(units.keys()))
        if unit_keys:
            return unit_keys[0]
    raise CronUnitNotFound()


class ServiceNotFound(Exception):
    """
    Exception thrown if a service cannot be found in the deployment or has
    no units.
    """

    def __init__(self, service_name):
        self.service_name = service_name


class CronUnitNotFound(Exception):
    """
    Exception thrown if the cron service cannot be found in a landscape
    unit.
    """


class Landscape1ServiceTests(unittest.TestCase):
    """
    Class hosting all the tests we want to run against a Landscape deployment.
    """

    @classmethod
    def setUpClass(cls):
        """Prepares juju_status which many tests use."""
        cls.juju_status = juju_status()
        cls.frontend = find_address(cls.juju_status, "apache2")

    def _check_url(self, url, good_content, post_data=None, header=None,
                   interval=10, attempts=30):
        """
        Polls the given URL looking for the specified good_content. Fails if
        the content cannot be found in time, otherwise returns True.

        @param url: URL to poll
        @param good_content: string we are looking for
        @param post_data: optional POST data string
        @param header: optional request header string
        @param interval: number of seconds between polls
        @param attempts: how many times we should poll
        """
        output = ""
        cmd = ["curl", url, "-k", "-L", "-s"]
        if post_data:
            cmd.extend(["-d", post_data])
        if header:
            cmd.extend(["-H", header])
        while True:
            output = check_output(cmd).decode("utf-8").strip()
            if good_content in output:
                break
            attempts = attempts - 1
            if attempts == 0:
                break
            sys.stdout.write(".")
            sys.stdout.flush()
            sleep(interval)
        self.assertIn(good_content, output)

    def __str__(self):
        file_name = os.path.splitext(os.path.basename(__file__))[0]
        return "{} ({}.{})".format(
            self._testMethodName, file_name, self.__class__.__name__)

    def test_app(self):
        """Verify that the APP service is up.

        Specifically that it is reachable and that it presents the new
        user form.
        """
        good_content = "New user - Landscape"
        self._check_url("https://{}/".format(self.frontend), good_content)

    def test_msg(self):
        """Verify that the MSG service is up.

        Specifically that it is reachable and that it responds
        correctly to requests.
        """
        good_content = "ds8:messagesl;s11:server-uuid"
        post_data = ("ds8:messagesl;s22:next-expected-sequencei0;s8:"
                     "sequencei0;;")
        header = "X-MESSAGE-API: 3.1"
        self._check_url("https://{}/message-system".format(self.frontend),
                        good_content, post_data, header)

    def test_ping(self):
        """Verify that the PING service is up.

        Specifically that it is reachable and that it responds
        correctly to a ping request without an ID.
        """
        good_content = "ds5:errors19:provide insecure_id;"
        self._check_url("http://{}/ping".format(self.frontend), good_content)

    def test_combo(self):
        """Verify that the COMBO service is up.

        Specifically that it is reachable and returns the expected text.
        """
        good_content = "Licensed under the BSD License"
        url = ("http://{}/combo?yui/scrollview/scrollview-min.js".format(
               self.frontend))
        self._check_url(url, good_content)

    def test_api(self):
        """Verify that the API service is up.

        Specifically that it is reachable and returns its name.
        """
        good_content = "Query API Service"
        self._check_url("https://{}/api".format(self.frontend), good_content)

    def test_ajax(self):
        """Verify that the AJAX srevice is up.

        Specifically that it is reachable and returns its name.
        """
        good_content = "Async frontend for landscape"
        self._check_url("https://{}/ajax".format(self.frontend), good_content)

    def test_upload(self):
        """Verify that the PACKAGE UPLOAD service is up.

        Specifically that it is reachable and returns its name.
        """
        good_content = "Landscape package upload service"
        # ending / is important because of the way we wrote this RewriteRule
        url = "https://{}/upload/".format(self.frontend)
        self._check_url(url, good_content)

    def test_static(self):
        """Verify that the STATIC service is up.

        Specifically, that we can reach a file that is hosted on the static
        server/unit.
        """
        good_content = "landscape-expandable-content"
        url = "https://{}/static/skin/manx/base.css".format(self.frontend)
        self._check_url(url, good_content)

    def test_ssh(self):
        """Verify that the landscape/0 unit can be reached via ssh."""
        good_content = "buffers/cache"
        output = check_output(["juju", "ssh", "landscape/0", "free -m"],
                              stderr=STDOUT).decode("utf-8")
        self.assertIn(good_content, output)


class LandscapeCronTests(unittest.TestCase):

    def __str__(self):
        file_name = os.path.splitext(os.path.basename(__file__))[0]
        return "{} ({}.{})".format(
            self._testMethodName, file_name, self.__class__.__name__)

    @classmethod
    def setUpClass(cls):
        cls.juju_status = juju_status()
        cls.cron_unit = find_cron_unit(cls.juju_status)
        cls._stop_cron(cls.cron_unit)

    @classmethod
    def tearDownClass(cls):
        cls._start_cron(cls.cron_unit)

    def _run_cron(self, script):
        status = 0
        # -q is to keep ssh quiet so that the only output we get is
        # from the script we are running
        cmd = ["juju", "ssh", self.cron_unit, "-q", "sudo", "-u landscape",
               script]
        try:
            output = check_output(
                cmd, stderr=STDOUT).decode("utf-8").strip()
        except CalledProcessError as e:
            output = e.output
            status = e.returncode
        # these jobs currently don't set their exit status to non-zero
        # if they fail, they just print things to stdout/stderr
        return (output.strip(), status)

    def test_maintenance_cron(self):
        """Verify that the maintenance cron job runs without errors."""
        script = "/opt/canonical/landscape/scripts/maintenance.sh"
        output, status = self._run_cron(script)
        self.assertEqual(output, "")
        self.assertEqual(status, 0)

    def test_update_security_db_cron(self):
        """Verify that the update_security_db cron job runs without errors."""
        script = "/opt/canonical/landscape/scripts/update_security_db.sh"
        output, status = self._run_cron(script)
        self.assertEqual(output, "")
        self.assertEqual(status, 0)

    def test_update_alerts_cron(self):
        """Verify that the update_alerts cron job runs without errors."""
        script = "/opt/canonical/landscape/scripts/update_alerts.sh"
        output, status = self._run_cron(script)
        self.assertEqual(output, "")
        self.assertEqual(status, 0)

    def test_process_profiles_cron(self):
        """Verify that the process_profiles cron job runs without errors."""
        script = "/opt/canonical/landscape/scripts/process_profiles.sh"
        output, status = self._run_cron(script)
        self.assertEqual(output, "")
        self.assertEqual(status, 0)

    def test_process_alerts_cron(self):
        """Verify that the process_alerts cron job runs without errors."""
        script = "/opt/canonical/landscape/scripts/process_alerts.sh"
        output, status = self._run_cron(script)
        self.assertEqual(output, "")
        self.assertEqual(status, 0)

    @unittest.skipIf(os.getenv("SKIP_SLOW_TESTS", None),
                     "Requested to skip slow tests.")
    def test_hash_id_databases_cron(self):
        """Verify that the hash_id_databases cron job runs without errors."""
        script = "/opt/canonical/landscape/scripts/hash_id_databases.sh"
        output, status = self._run_cron(script)
        self.assertEqual(output, "")
        self.assertEqual(status, 0)

    def test_meta_releases_cron(self):
        """Verify that the meta_releases cron job runs without errors."""
        script = "/opt/canonical/landscape/scripts/meta_releases.sh"
        output, status = self._run_cron(script)
        self.assertEqual(output, "")
        self.assertEqual(status, 0)

    def test_sync_lds_releases_cron(self):
        """Verify that the sync_lds_releases cron job runs without errors."""
        script = "/opt/canonical/landscape/scripts/sync_lds_releases.sh"
        output, status = self._run_cron(script)
        self.assertEqual(output, "")
        self.assertEqual(status, 0)

    def test_maas_poller_cron(self):
        """Verify that the maas_poller cron job runs without errors."""
        script = "/opt/canonical/landscape/scripts/maas_poller.sh"
        output, status = self._run_cron(script)
        self.assertEqual(output, "")
        self.assertEqual(status, 0)

    def _stop_cron(unit):
        cmd = ["juju", "ssh", unit, "-q", "sudo", "service", "cron", "stop"]
        check_output(cmd, stderr=STDOUT)

    def _start_cron(unit):
        cmd = ["juju", "ssh", unit, "-q", "sudo", "service", "cron",
               "start"]
        check_output(cmd, stderr=STDOUT)


if __name__ == "__main__":
    unittest.main(verbosity=2)
