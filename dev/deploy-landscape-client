#!/usr/bin/python3
"""
This script looks at the current Juju environment and generates a
juju-deployer config for landscape-client that is configured to talk to
the deployed landscape-server service. The URLs and SSL certificate are
taken from the deployed landscape-server units.

By default, landscape-client will be deployed, but you can choose to
only generate the juju-deployer config and deploy manually:

    deploy-landscape-client --no-deploy > landscape-client.yaml
"""

# This import isn't strictly needed, since we don't need to support
# Python2, but this makes linting easier, since we have a mix of Python2
# and Python3 in the charm
from __future__ import print_function

import argparse
import os.path
import shutil
import subprocess
import sys
import tempfile

import yaml


def get_landscape_unit():
    """Get the name of any landscape-server unit."""
    status = yaml.load(subprocess.check_output(
        ["juju", "status", "--format", "yaml", "landscape-server"]))
    units = status["services"]["landscape-server"]["units"]
    # Any landscape-server unit will do.
    return next(iter(units.keys()))


def get_ssl_cert(landscape_unit, tempdir, ca_cert_name):
    """Fetch the SSL certificate from the Landscape unit.

    The certficate is saved into tempdir, and the full path is returned.
    """
    ca_cert_name = "landscape_server_ca.crt"
    ca_cert_path = os.path.join(tempdir, ca_cert_name)
    subprocess.check_call(
        ["juju", "scp",
         "{}:/etc/ssl/certs/{}".format(landscape_unit, ca_cert_name),
         ca_cert_path])
    return ca_cert_path


def get_hostname(ca_cert_path, stderr):
    """Get the common name from a SSL certificate.

    None is return if there is no CN in the certificate.
    """
    ca_subject = subprocess.check_output(
        ["openssl", "x509", "-in", ca_cert_path, "-subject", "-noout"])
    for subject in ca_subject.decode("utf-8").split("/"):
        subject = subject.strip()
        if subject.startswith("CN="):
            break
    else:
        error_msg = "Couldn't find the common name in {}: {}".format(
            ca_cert_path, ca_subject)
        print(error_msg, file=stderr)
        return None

    _, host = subject.split("=", 1)
    return host


def generate_deploy_config(ca_cert_path, host):
    """Generate a juju-deployer config.

    Return the YAML config as a string.
    """
    ca_base64 = subprocess.check_output(
        ["openssl", "base64", "-in", ca_cert_path, "-e"]).decode("utf-8")
    deployer_config = {
        "landscape-client": {
            "series": "trusty",
            "services": {
                "landscape-client": {
                    "charm": "cs:trusty/landscape-client",
                    "options": {
                        "account-name": "standalone",
                        "url": "https://{}/message-system".format(host),
                        "ping-url": "http://{}/ping".format(host),
                        "ssl-public-key": "base64:{}".format(ca_base64),
                        }}}}}
    return yaml.safe_dump(deployer_config)


def main(args, stdout=sys.stdout, stderr=sys.stderr):
    tempdir = tempfile.mkdtemp()
    landscape_unit = get_landscape_unit()

    ca_cert_name = "landscape_server_ca.crt"
    print(
        "Copying {} from {}".format(ca_cert_name, landscape_unit), file=stderr)
    ca_cert_path = get_ssl_cert(landscape_unit, tempdir, ca_cert_name)

    host = get_hostname(ca_cert_path, stderr)
    if host is None:
        return 1

    print("Generating deployer config.", file=stderr)
    yaml_config = generate_deploy_config(ca_cert_path, host)
    config_path = os.path.join(tempdir, "landscape-client.yaml")
    with open(config_path, "w") as f:
        f.write(yaml_config)
    print(yaml_config, file=stdout)

    if args.deploy:
        print("Deploying landscape-client.", file=stderr)
        subprocess.check_call(["juju-deployer", "-c", config_path])
    print("Cleaning up {}".format(tempdir), file=stderr)
    shutil.rmtree(tempdir)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--no-deploy", dest="deploy", action="store_false", default=True,
        help="Only generate deployer config, don't deploy service.")
    args = parser.parse_args()
    sys.exit(main(args))
