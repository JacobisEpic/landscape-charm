#!/usr/bin/python3

import os
import logging
import shutil
import subprocess
import tempfile
import time
import yaml
from argparse import ArgumentParser

CHARM_SRC = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))


class Deployer(object):
    """Simple wrapper around juju deploy (used to be juju-deployer).

    It creates a temporary directory that will act as local charm repository
    for juju deploy so it can deploy the current charm branch as local
    charm.

    It also overrides the configuration in the stock bundles, accounting for
    these files:

      - config/repo-file
      - config/license-file
      - config/ssl-cert
      - config/ssl-key

    that can be used to provide custom parameters.
    """

    def __init__(self, args):
        self.juju_version = 1
        version = subprocess.check_output(["juju", "version"]).decode("utf-8")
        if version.startswith("2"):
            self.juju_version = 2
        self._args = args

    def _stage_deployer_dir(self, deployer_dir, series):
        """Stage the directory for calling deployer."""
        series_dest = os.path.join(deployer_dir, series)
        os.mkdir(series_dest)
        charm_dest = os.path.join(series_dest, "landscape-server")
        os.symlink(CHARM_SRC, charm_dest)

    def _create_local_yaml(self, tmpdir, source_bundle_file):
        """
        Create a local yaml file to adjust settings in the bundle.  Return the
        created file name to the caller.

        @param tmpdir: directory where we can write a yaml file.
        @param source_bundle_file: The bundle file to override.
        """
        # Will create a config file with option values overridden for use in
        # the juju deploy commandline to add a custom license-file to the
        # deployment.
        local_yaml_file = os.path.join(tmpdir, "99-local.yaml")
        with open(source_bundle_file, "r") as bundle_content:
            local_yaml = yaml.safe_load(bundle_content.read())

        # overridden options in landscape-charm, with the filename in the
        # config dir that we read.
        override_options = {"source": "repo-file",
                            "license-file": "license-file",
                            "ssl-cert": "ssl-cert",
                            "ssl-key": "ssl-key"}

        # Add our option values to the existing YAML
        options = {}
        for option, filename in override_options.items():
            filepath = os.path.join(CHARM_SRC, "config", filename)
            if os.path.exists(filepath):
                options[option] = "include-file://%s" % filepath
        local_yaml["services"]["landscape-server"]["options"].update(options)

        with open(local_yaml_file, "w") as f:
            f.write(yaml.dump(local_yaml, default_flow_style=False))
        return local_yaml_file

    def deploy(self, timeout=900):
        """
        Use juju deploy to deploy the target deployment type on current
        juju model.

        @param timeout: timeout in seconds (int or string is OK)
        """
        target = self._args.target
        start = time.time()
        target = "landscape-" + target
        deployer_dir = None
        original_bundle = os.path.join(
            CHARM_SRC, "bundles", "build", target, "bundle.yaml")
        try:
            deployer_dir = tempfile.mkdtemp()
            # Stage deployer directory for all supported series, even though
            # typically in a deploy attempt only one series is used.  Since
            # it's determined by a bundle, we have to be ready for whatever.
            for series in ["trusty", "xenial"]:
                self._stage_deployer_dir(deployer_dir, series)
            updated_bundle_file = self._create_local_yaml(
                deployer_dir, original_bundle)
            args = ["juju", "deploy"]
            args.append(updated_bundle_file)
            logging.info("(cwd=%s) RUN: %s" % (deployer_dir, args))
            subprocess.check_call(args, cwd=deployer_dir)
            logging.info("Waiting for relations to settle")
            subprocess.check_output([
                "juju", "run", "--all", "--timeout={}s".format(timeout),
                "/bin/true"])
            deploy_time = int(round(time.time() - start))
            logging.info(
                "Deployment usable after {} seconds".format(deploy_time))
            juju_status = yaml.load(subprocess.check_output([
                "juju", "status", "--format=yaml"]))
            haproxies = juju_status["applications"]["haproxy"]["units"]
            haproxy_ip = list(haproxies.values())[0]["public-address"]
            logging.info("Landscape URL: https://{}/".format(haproxy_ip))
        finally:
            if deployer_dir is not None:
                shutil.rmtree(deployer_dir)
        self._enable_flags()

    def _enable_flags(self):
        """Enable feature flags."""
        command = "sudo /opt/canonical/landscape/featureflags enable {}"
        for flag in self._args.flags:
            # Run the command on all units, rather than having to figure
            # out which unit to run it on.
            if self.juju_version == 1:
                option = "--service"
            else:
                option = "--application"
            subprocess.check_output([
                "juju", "run", option, "landscape-server",
                command.format(flag)])


def get_parser():
    parser = ArgumentParser(description="Simple wrapper around juju deploy")
    parser.add_argument(
        "target", choices=("scalable", "dense", "dense-maas"),
        help="target deployment type")
    parser.add_argument(
        "--flags", nargs="+", default=[], help="feature flags to enable")
    return parser

if __name__ == "__main__":
    args = get_parser().parse_args()
    logging.basicConfig(level=logging.INFO)
    deployer = Deployer(args)
    deployer.deploy()
