#!/usr/bin/python3

import os
import logging
import shutil
import subprocess
import tempfile
import sys

import yaml

CHARM_SRC = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))


class Deployer(object):
    """Simple wrapper around juju-deployer.

    It creates a temporary directory that will act as local charm repository
    for juju-deployer, so it can deploy the current charm branch as local
    charm.

    It also overrides the configuration in the stock bundles, accounting for
    these files:

      - config/repo-file
      - config/license-file
      - config/ssl-cert
      - config/ssl-key

    that can be used to provide custom parameters.
    """

    def _stage_deployer_dir(self, deployer_dir, series):
        """Stage the directory for calling deployer."""
        series_dest = os.path.join(deployer_dir, series)
        os.mkdir(series_dest)
        charm_dest = os.path.join(series_dest, "landscape-server")
        os.symlink(CHARM_SRC, charm_dest)

    def _create_local_yaml(self, tmpdir, target):
        """
        Create a local yaml file to adjust settings in the bundle.  Return the
        created file name to the caller.

        @param tmpdir: directory where we can write a yaml file.
        @param target: what bundle target to override.
        """
        # Will be appended to end of 'config_files' list.  This will in turn
        # be specified last on the juju-deployer command line, and will be able
        # to overwrite charm settings.  For instance we can use it to add a
        # custom license-file to the deployment.
        local_yaml_file = os.path.join(tmpdir, "99-local.yaml")
        local_yaml = {}

        # overridden options in landscape-charm, with the filename in the
        # config dir that we read.
        override_options = {"source": "repo-file",
                            "license-file": "license-file",
                            "ssl-cert": "ssl-cert",
                            "ssl-key": "ssl-key"}

        # Base data structure for the landscape-charm that we will fill out
        # with options.
        landscape_service = {"charm": "landscape-server"}
        options = {}
        for option, filename in override_options.items():
            filepath = os.path.join(CHARM_SRC, "config", filename)
            if os.path.exists(filepath):
                options[option] = "include-file://%s" % filepath

        # Can't include a blank options section, deployer will choke
        if options:
            landscape_service["options"] = options

        # target name == filename in our bundles branches.
        local_yaml[target] = {"services": {}}
        for service in ["landscape-server"]:
            local_yaml[target]["services"][service] = landscape_service

        with open(local_yaml_file, "w") as f:
            f.write(yaml.dump(local_yaml, default_flow_style=False))
        return local_yaml_file

    def deploy(self, target, timeout=900):
        """
        Use juju-deployer to install `target` on current `juju env`

        @param target: target to deploye in the config file.
        @param timeout: timeout in seconds (int or string is OK)
        """
        target = "landscape-" + target
        deployer_dir = None
        config_files = [os.path.join(CHARM_SRC, "bundles", target + ".yaml")]
        try:
            deployer_dir = tempfile.mkdtemp()
            # Stage deployer directory for all supported series, even though
            # typically in a deploy attempt only one series is used.  Since
            # it's determined by a bundle, we have to be ready for whatever.
            for series in ["precise", "trusty"]:
                self._stage_deployer_dir(deployer_dir, series)
            config_files.append(
                self._create_local_yaml(deployer_dir, target))
            args = ["juju-deployer", "-vdWL", "-w 180"]
            for config_file in config_files:
                args.extend(["-c", config_file])
            args.append(target)
            if timeout is not None:
                args.extend(["--timeout", str(timeout)])
            logging.info("(cwd=%s) RUN: %s" % (deployer_dir, args))
            subprocess.check_call(args, cwd=deployer_dir)
        finally:
            if deployer_dir is not None:
                shutil.rmtree(deployer_dir)


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: %s <target>" % sys.argv[0])
        print("   <target> can be either 'scalable', 'dense' or 'dense-maas'")
        sys.exit(1)
    deployer = Deployer()
    deployer.deploy(sys.argv[1])
